/**
 * @markdown
 * # JavaScript API Reference
 *
 * ## Notes
 *
 * - Using JS API is completely optional in shogi-ui. What's done by JS API can
 *   also be done by plain HTML.
 * - Parameters prefixed with `$` represent HTML/SVG elements.
 * - This document is generated by `scripts/jsdoc.py`.
 */
(function (global) {

/**
 * @markdown
 * ## Constants
 */

/**
 * An array containing all possible Koma type strings.
 * @public
 * @const {Array<string>}
 *
 * It's in the following order: `王玉飛龍角馬金銀全桂圭香杏歩と`.
 */
const komaTypes = [
  '王', '玉',
  '飛', '龍',
  '角', '馬',
  '金',
  '銀', '全',
  '桂', '圭',
  '香', '杏',
  '歩', 'と',
];

/** @enum {string} */
const classes = {
  board: 'shogi__board',
  sujiTextRow: 'shogi__suji_text_row',
  sujiText: 'shogi__suji_text',
  danText: 'shogi__dan_text',
  danRow: 'shogi__dan_row',
  boardDot: 'shogi__board__dot',
  cell: 'shogi__cell',
  cellHighlighted: 'shogi__cell--highlighted',
  koma: 'shogi__koma',
  komaSelected: 'shogi__koma--selected',
  mochigomas: 'shogi__mochigomas',
  mochigomasKoutei: 'shogi__mochigomas--koutei',
  mochigoma: 'shogi__mochigoma',
  mochigomaKoma: 'shogi__mochigoma__koma',
  mochigomaCount: 'shogi__mochigoma__count',
};

/**
 * @typedef {Array<!Object<string, string>>}
 *
 * The Array type is actually a binary tuple, the first element of which is for
 * Sentei and the other is for Koutei.
 */
var PlayerDependentAttributes;

/** @enum {number} */
const player = {
  sentei: 0,
  koutei: 1,
};

/**
 * @param {!Object<string, (string|!Array<string>)>} attributes
 * @return {!PlayerDependentAttributes}
 */
function playerDependentAttributes(attributes) {
  const sentei = {};
  const koutei = {};
  for (const key in attributes) {
    const value = attributes[key];
    if (Array.isArray(value)) {
      sentei[key] = value[player.sentei];
      koutei[key] = value[player.koutei];
    } else {
      sentei[key] = value;
      koutei[key] = value;
    }
  }
  return [sentei, koutei];
}

/**
 * @const {{
 *   root: !PlayerDependentAttributes,
 *   koma: !PlayerDependentAttributes,
 *   komaSide: !PlayerDependentAttributes,
 *   komaType: !PlayerDependentAttributes,
 * }}
 */
const svg = {
  root: playerDependentAttributes({
    'class': classes.koma,
    'viewBox': '0 0 250 250',
  }),

  koma: playerDependentAttributes({
    'points': [
      '125,0 195,30 235,238 15,238 55,30',
      '125,238 195,208 235,0 15,0 55,208',
    ],
    'fill': 'rgb(221,190,138)',
  }),

  komaSide: playerDependentAttributes({
    'points': [
      '15,238 235,238 232,250 18,250',
      '125,238 195,208 192,220 125,250 58,220 55,208',
    ],
    'fill': 'rgb(133,111,83)',
  }),

  komaType: playerDependentAttributes({
    'text-anchor': 'middle',
    'dominant-baseline': 'middle',
    'font-size': '120px',
    'x': '125',
    'y': ['145', '93'],
    'transform': ['', 'rotate(180,125,93)'],
  }),
};

/**
 * @markdown
 * ## Element factories
 */

/**
 * An option type to indicate the method is called for Sentei.
 * @public
 * @typedef {{sentei: boolean}}
 *
 * Set the `sentei` field to `true` for Sentei, and `false` for Koutei.
 */
var SenteiOption;

/**
 * Creates an `svg` element of a Koma.
 * @public
 * @param {string} type One of the Koma type in `komaTypes`.
 * @param {SenteiOption} option
 * @return {!Element}
 *
 * The returned element can be used as the `$koma` parameter of other methods.
 */
function komaSVG(type, option) {
  const playerIndex = option['sentei'] ? player.sentei : player.koutei;

  const $svg = $('svg', svg.root[playerIndex]);

  const $koma = $('polygon', svg.koma[playerIndex]);
  const $komaSide = $('polygon', svg.komaSide[playerIndex]);
  const $komaType = $('text', svg.komaType[playerIndex]);
  $komaType.textContent = type;

  $svg.appendChild($koma);
  $svg.appendChild($komaSide);
  $svg.appendChild($komaType);

  return $svg;
}

/**
 * Creates a `div` element of the Shogi board.
 * @public
 * @return {!Element}
 *
 * The returned element can be used as the `$board` parameter of other methods.
 */
function boardDiv() {
  const $board = $('div', {'class': classes.board});

  const $sujiTextRow = $('div', {'class': classes.sujiTextRow});
  for (let suji = 9; suji >= 1; suji--) {
    const $sujiText = $('div', {'class': classes.sujiText});
    $sujiText.textContent = suji;
    $sujiTextRow.appendChild($sujiText);
  }
  $sujiTextRow.appendChild($('div', {'class': classes.danText}));
  $board.appendChild($sujiTextRow);

  for (let dan = 1; dan <= 9; dan++) {
    const $danRow = $('div', {'class': classes.danRow});

    for (let suji = 9; suji >= 1; suji--) {
      if ((suji == 3 || suji == 6) && (dan == 3 || dan == 6)) {
        const $dot = $('div', {'class': classes.boardDot});
        $danRow.appendChild($dot);
      }

      const $cell = $('div', {'class': classes.cell});
      $danRow.appendChild($cell);
    }

    const $danText = $('div', {'class': classes.danText});
    const $danTextSpan = $('span');
    $danTextSpan.textContent = kanjiFromNumber(dan);
    $danText.appendChild($danTextSpan);
    $danRow.appendChild($danText);

    $board.appendChild($danRow);
  }

  return $board;
}

/**
 * Creates a `div` element of a Mochigoma container.
 * @public
 * @return {!Element}
 *
 * The returned element can be used as the `$mochigomas` parameter of other
 * methods.
 *
 * This method creates an empty container. Call `setMochigomas` to actually set
 * the Mochigoma status.
 */
function mochigomasDiv() {
  const $mochigomas = $('div', {'class': classes.mochigomas});
  for (let i = 0; i < 7; i++) {
    const $mochigoma = $('div', {'class': classes.mochigoma});
    $mochigoma.appendChild($('div', {'class': classes.mochigomaKoma}));
    $mochigoma.appendChild($('div', {'class': classes.mochigomaCount}));
    $mochigomas.appendChild($mochigoma);
  }
  return $mochigomas;
}

/**
 * @markdown
 * ## Cell
 */

/**
 * An object type representing a Koma position.
 * @public
 * @typedef {{suji: number, dan: number}}
 */
var Position;

/**
 * Returns the cell element at the given position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 * @return {!Element}
 *
 * The returned element can be used as the `$cell` parameter of other methods.
 */
function cellAt($board, position) {
  const sujiIdx = 9 - position['suji'];
  const danRowIdx = position['dan'] - 1;

  const $danRow = queryClassAll($board, classes.danRow)[danRowIdx];
  return queryClassAll($danRow, classes.cell)[sujiIdx];
}

/**
 * Highlights a cell.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 *
 * This method manipulates classes of the cell element.
 */
function highlightCellAt($board, position) {
  const $cell = cellAt($board, position);
  $cell.classList.add(classes.cellHighlighted);
}

/**
 * Unhighlights a cell.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 *
 * This method manipulates classes of the cell element.
 */
function unhighlightCellAt($board, position) {
  const $cell = cellAt($board, position);
  $cell.classList.remove(classes.cellHighlighted);
}

/**
 * `true` if the given cell is highlighted.
 * @public
 * @param {!Element} $cell
 * @return {boolean}
 */
function cellHighlighted($cell) {
  return $cell.classList.contains(classes.cellHighlighted);
}

/**
 * `true` if the cell at the given position is highlighted.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 * @return {boolean}
 */
function cellHighlightedAt($board, position) {
  return cellHighlighted(cellAt($board, position));
}

/**
 * @markdown
 * ## Koma
 */

/**
 * Returns the Koma element at the given position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 * @return {?Element}
 *
 * `null` is returned when there is no Koma at the given position.
 *
 * The returned non-null element can be used as the `$koma` parameter of other
 * methods.
 */
function komaAt($board, position) {
  return komaIn(cellAt($board, position));
}

/**
 * Returns the Koma element in the given cell.
 * @public
 * @param {!Element} $cell
 * @return {?Element}
 *
 * It's nullable for the case where no Koma exists in the given cell.
 *
 * The returned non-null element can be used as the `$koma` parameter of other
 * methods.
 */
function komaIn($cell) {
  const $koma = queryClass($cell, classes.koma);
  return $koma || null;
}

/**
 * Select a Koma.
 * @public
 * @param {!Element} $koma
 *
 * This method manipulates classes of the Koma element.
 */
function selectKoma($koma) {
  $koma.classList.add(classes.komaSelected);
}

/**
 * Unselect a Koma.
 * @public
 * @param {!Element} $koma
 *
 * This method manipulates classes of the Koma element.
 */
function unselectKoma($koma) {
  $koma.classList.remove(classes.komaSelected);
}

/**
 * `true` if the given koma is selected.
 * @public
 * @param {!Element} $koma
 * @return {boolean}
 */
function komaSelected($koma) {
  return $koma.classList.contains(classes.komaSelected);
}

/**
 * Select a Koma at the given position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 *
 * It's ignored if there is no Koma at the given position.
 *
 * This method manipulates classes of the existing Koma element.
 */
function selectKomaAt($board, position) {
  const $koma = komaAt($board, position);
  $koma && selectKoma($koma);
}

/**
 * Unselect a Koma at the given position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 *
 * It's ignored if there is no Koma at the given position.
 *
 * This method manipulates classes of the existing Koma element.
 */
function unselectKomaAt($board, position) {
  const $koma = komaAt($board, position);
  $koma && unselectKoma($koma);
}

/**
 * `true` if the koma at the given position is selected.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 * @return {?boolean}
 *
 * `null` is returned` when there is no Koma at the given position.
 */
function komaSelectedAt($board, position) {
  const $koma = komaAt($board, position);
  return $koma && komaSelected($koma);
}

/**
 * Puts a Koma at a position.
 * @public
 * @param {!Element} $board
 * @param {!Element} $koma
 * @param {!Position} position
 *
 * Any existing Koma will be replaced.
 */
function putKomaAt($board, $koma, position) {
  removeKomaAt($board, position);
  const $cell = cellAt($board, position);
  $cell.appendChild($koma);
}

/**
 * Removes a Koma at a position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 *
 * It's ignored if there is no Koma at the given position.
 */
function removeKomaAt($board, position) {
  const $cell = cellAt($board, position);
  const $existingKoma = komaIn($cell);
  if ($existingKoma) {
    $cell.removeChild($existingKoma);
  }
}

/**
 * Returns the type of the given Koma.
 * @public
 * @param {!Element} $koma
 * @return {string}
 */
function komaType($koma) {
  return $koma.textContent.trim();
}

/**
 * Returns the type of the Koma in the given cell.
 * @public
 * @param {!Element} $cell
 * @return {?string}
 *
 * `null` is returned when there is no Koma in the cell.
 */
function komaTypeIn($cell) {
  const $koma = komaIn($cell)
  return $koma && komaType($koma);
}

/**
 * Returns the type of the Koma in the given position.
 * @public
 * @param {!Element} $board
 * @param {!Position} position
 * @return {?string}
 *
 * `null` is returned when there is no Koma at the given position.
 */
function komaTypeAt($board, position) {
  return komaTypeIn(cellAt($board, position));
}

/**
 * @markdown
 * ## Mochigoma
 */

/**
 * An object type representing a Mochigoma status for one Koma type.
 * @public
 * @typedef {{type: string, count: number}}
 */
var Mochigoma;

/**
 * Sets the Mochigoma status.
 * @public
 * @param {!Element} $mochigomas The Mochigoma container element.
 * @param {!Array<!Mochigoma>} mochigomas
 * @param {SenteiOption} option
 *
 * Note that the maximum length of `mochigomas` is 7. The status will be
 * displayed in the same order of the given objects.
 *
 * This method manipulates classes of the Mochigoma container element by the
 * Sentei option.
 */
function setMochigomas($mochigomas, mochigomas, option) {
  if (option['sentei']) {
    $mochigomas.classList.remove(classes.mochigomasKoutei);
  } else {
    $mochigomas.classList.add(classes.mochigomasKoutei);
  }

  const all$mochigoma = queryClassAll($mochigomas, classes.mochigoma);
  for (let i = 0; i < 7; i++) {
    const $mochigoma = all$mochigoma[i];
    const $koma = /** @type {!Element} */ (
      queryClass($mochigoma, classes.mochigomaKoma));
    const $count = queryClass($mochigoma, classes.mochigomaCount);

    // Clear existing contents.
    const $existingKomaSVG = komaIn($koma);
    $existingKomaSVG && $koma.removeChild($existingKomaSVG);
    $count.textContent = '';

    const {type, count} = mochigomas[i] || {};
    if (type) {
      $koma.appendChild(komaSVG(type, option));
      $count.textContent = count;
    }
  }
}

/**
 * Returns the Mochigoma status.
 * @public
 * @param {!Element} $mochigomas
 * @return {!Array<!Mochigoma>}
 *
 * The returned array will be in the same order of the visible status.
 */
function getMochigomas($mochigomas) {
  const all$mochigoma = queryClassAll($mochigomas, classes.mochigoma);
  const mochigomas = [];
  for (let i = 0; i < 7; i++) {
    const $mochigoma = all$mochigoma[i];
    const $koma = /** @type {!Element} */ (
      queryClass($mochigoma, classes.mochigomaKoma));
    const $count = queryClass($mochigoma, classes.mochigomaCount);

    const type = komaTypeIn($koma);
    const count = parseInt($count.textContent, 10);

    if (type) {
      mochigomas[i] = {type, count};
    }
  }
  return mochigomas;
}

// Utility Functions

/**
 * @const {Set<string>}
 *
 * Note that this is not the exhaustive list of the SVG tag names, but a list
 * used in this module.
 */
const svgTagNames = new Set(['svg', 'polygon', 'text']);

/**
 * @param {string} tagName
 * @param {!Object<string, string>=} attributes
 * @return {!Element}
 */
function $(tagName, attributes={}) {
  const $el = svgTagNames.has(tagName)
    ? document.createElementNS('http://www.w3.org/2000/svg', tagName)
    : document.createElement(tagName);
  for (const key in attributes) {
    $el.setAttribute(key, attributes[key]);
  }
  return $el;
}

/** @const {Array<string>} */
const numberKanjis = [
  '一', '二', '三', '四', '五', '六', '七', '八', '九', '十'];

/**
 * @param {number} number
 * @return {string}
 */
function kanjiFromNumber(number) {
  return numberKanjis[number - 1];
}

/**
 * @param {string} kanji
 * @return {number}
 */
function numberFromKanji(kanji) {
  return numberKanjis.indexOf(kanji) + 1;
}

/**
 * @param {!Element} $container
 * @param {string} className
 * @return {?Element}
 */
function queryClass($container, className) {
  return $container.querySelector('.' + className);
}

/**
 * @param {!Element} $container
 * @param {string} className
 * @return {!NodeList<!Element>}
 */
function queryClassAll($container, className) {
  return $container.querySelectorAll('.' + className);
}

// Exports the global variable.
global['Shogi'] = {
  // Constants
  'komaTypes': komaTypes,

  // Element factories
  'komaSVG': komaSVG,
  'boardDiv': boardDiv,
  'mochigomasDiv': mochigomasDiv,

  // Cell
  'cellAt': cellAt,
  'highlightCellAt': highlightCellAt,
  'unhighlightCellAt': unhighlightCellAt,
  'cellHighlighted': cellHighlighted,
  'cellHighlightedAt': cellHighlightedAt,

  // Koma
  'komaAt': komaAt,
  'komaIn': komaIn,
  'selectKoma': selectKoma,
  'unselectKoma': unselectKoma,
  'komaSelected': komaSelected,
  'selectKomaAt': selectKomaAt,
  'unselectKomaAt': unselectKomaAt,
  'komaSelectedAt': komaSelectedAt,
  'putKomaAt': putKomaAt,
  'removeKomaAt': removeKomaAt,
  'komaType': komaType,
  'komaTypeAt': komaTypeAt,
  'komaTypeIn': komaTypeIn,

  // Mochigoma
  'setMochigomas': setMochigomas,
  'getMochigomas': getMochigomas,
};

})(typeof globalThis == 'object' ? globalThis : window);
